#pragma once
#include "../../../SFC/essentials.h"

#ifndef RVM_HASH_SIZE
#define RVM_HASH_SIZE		(32U)
#endif

namespace rvm
{

enum class SecSuite: uint8_t
{
	Unknown = 0,

	Cryptography = 1,			// address is a public key, signing by private key
	Ethereum = Cryptography,	// ethereum
	Reserved1,					// 
	Ed25519,					// default
	CryptographyMax,

	NoSigning = 4,				// address is not sign-able at all
	Contract = NoSigning,		// it's a contract, converted from the contract's id
	Custom,						// some address procedurally generated by code
	NoSigningMax,

	Delegated	= 8,			// address is not based on a public key, signing is delegated to a address of Cryptography type
	DelegatedAsHash = Delegated,
	DelegatedAsName,
	DelegatedAsDApp,
	DelegatedAsToken,
	DelegatedMax,
			
	None = 0xff
};

static_assert(uint8_t(SecSuite::CryptographyMax) <= uint8_t(SecSuite::NoSigning), "CryptographyMax section overlaps with NoSigning section");
static_assert(uint8_t(SecSuite::NoSigningMax) <= uint8_t(SecSuite::Delegated), "NoSigningMax section overlaps with Delegated section");

struct Address
{	
	uint8_t		_[RVM_HASH_SIZE];
	union {
	int			_SSID:4;
	uint32_t	_CheckSum;
	};
};
typedef const Address ConstAddress;
static_assert(sizeof(Address) == 36);

// 6-bit
enum class ScopeKeySize : uint8_t
{
	// non-Enumerable
	Default = 0,	// actual scope is defined on scope_slot
	Address = 0,	// address (slot #0, #1, #2 were occupied for ScopeType::Contract, slot for customized address scope should starts from #3)
	UInt32,			// uint32_t	: 4B
	UInt64,			// uint64_t	: 8B
	UInt96,			// uint96_t	: 12B
	UInt128,		// SHA128	: 16B
	UInt160,		// SHA160	: 20B
	UInt256,		// SHA256	: 32B
	UInt512,		// SHA512	: 64B
	// Enumerable
	AddressEnumerable = 0x20,	// address
	UInt32Enumerable,			// uint32_t
	UInt64Enumerable,			// uint64_t
	UInt96Enumerable,			// uint96_t
	UInt128Enumerable,			// MD5/uint128_t
	UInt160Enumerable,			// SHA160		
	UInt256Enumerable,			// SHA256		
	UInt512Enumerable,			// SHA512

	Bitmask = 0x3fu,
	BaseTypeBitmask = 0x1fu,
	IsEnumerable = 0x20u
};

static const ScopeKeySize ScopeKeySizeInvalid = ScopeKeySize::Bitmask;

struct ScopeKey
{
	const uint8_t*	Data;
	uint32_t		Size;
};

template<int SZ>
inline constexpr uint32_t	SCOPEKEY_SHARD_DWORD(const uint8_t* p)
							{	const uint32_t* d = (const uint32_t*)p;
								if		constexpr (SZ == 1)return *(uint8_t*)d;
								else if constexpr (SZ == 2)return *(uint16_t*)d;
								else if constexpr (SZ == 3)return (*(uint32_t*)d) & 0xffffffU;
								else if constexpr (SZ == 4)return *d;
								else if constexpr (SZ == 36)return d[0] ^ d[4] ^ d[7]; // TBD: remove when code is stable
								else return d[0] ^ d[SZ/8] ^ d[SZ/4 - 1];
							}
inline constexpr uint32_t	SCOPEKEY_SHARD_DWORD(const ScopeKey& k)
							{	const uint32_t* d = (const uint32_t*)k.Data;
								if(k.Size == 36)return d[0] ^ d[4] ^ d[7];  // TBD: remove when code is stable
								return d[0] ^ d[k.Size/8] ^ d[k.Size/4 - 1];
							}
inline uint32_t				SCOPEKEY_SHARD_BITMASK(uint32_t shard_order){ return ~(((uint32_t)(-1))<<shard_order); }
inline uint32_t				SCOPEKEY_SHARD_BRANCH_BIT(uint32_t shard_order){ return shard_order?(1U<<(shard_order-1)):0; } // 0 for base, otherwise for up
inline constexpr int		SCOPEKEY_SIZE(ScopeKeySize t)
							{	switch((ScopeKeySize)(uint16_t(ScopeKeySize::BaseTypeBitmask)& uint16_t(t)))
								{	case ScopeKeySize::UInt32: return 4;
									case ScopeKeySize::UInt64: return 8;
									case ScopeKeySize::UInt96: return 12;
									case ScopeKeySize::UInt128: return 16;
									case ScopeKeySize::UInt160: return 20;
									case ScopeKeySize::UInt256: return 32;
									case ScopeKeySize::Address: return 36;
									case ScopeKeySize::UInt512: return 64;
									default: return -1;
								}
							}
inline constexpr bool		SCOPEKEYSIZE_SHOULD_REFER(ScopeKeySize t){ return t==ScopeKeySize::Default || ((int)t&(int)ScopeKeySize::BaseTypeBitmask) >= (int)ScopeKeySize::UInt160; }

static const uint32_t		ADDRESS_DWORD_SIZE = sizeof(Address)/sizeof(uint32_t);
static const uint32_t		ADDRESS_BASE32_LEN = (sizeof(Address)*8 + 4)/5; // 58
static const uint32_t		ADDRESS_ABBREVIATION_LEN = 7;  //  xxx:yyy

inline 			 uint32_t	ADDRESS_SHARD_DWORD(const Address& a){ return SCOPEKEY_SHARD_DWORD<sizeof(Address)>((uint8_t*)&a); }
inline constexpr uint32_t	ADDRESS_SHARD_BITMASK(uint32_t shard_order){ return ~(((uint32_t)(-1))<<shard_order); }
inline 			 uint32_t	ADDRESS_SHARD_INDEX(const Address& a, uint32_t shard_order){ return ADDRESS_SHARD_DWORD(a)&ADDRESS_SHARD_BITMASK(shard_order); }
inline constexpr SecSuite	ADDRESS_SECSUITE_ID(const Address& a){ return (SecSuite)(a._SSID); }
inline			 bool		ADDRESS_IS_VALID(const Address& a){ return !(0xfffffff0 & (a._CheckSum ^ os::crc32c(a._, RVM_HASH_SIZE, (uint32_t)ADDRESS_SECSUITE_ID(a)))); }
inline			 void		ADDRESS_SET_SECSUITE(Address& a, SecSuite ssid){ a._CheckSum = ((uint8_t)ssid&0xf) | (0xfffffff0 & os::crc32c(a._, RVM_HASH_SIZE, (uint32_t)ssid)); }

} // namespace rvm