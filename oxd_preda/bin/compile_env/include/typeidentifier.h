#pragma once
#include <cstdint>

namespace prlrt {

	// Never change order of elements or remove any element
	// Only append at the end
	enum class type_identifier_enum : uint8_t {
		// There's no need to have "___" prefix on the members since they are in the class scope and wouldn't mix with user code
		// However, some would then conflict with c++ keyword...
		___bool = 0,
		___int8,
		___int16,
		___int32,
		___int64,
		___int128,
		___int256,
		___int512,
		___uint8,
		___uint16,
		___uint32,
		___uint64,
		___uint128,
		___uint256,
		___uint512,
		___bigint,
		___blob,
		___hash,
		___address,
		___token,
		___string,
		___array,
		___map,
		___struct,
		___enum,
		___float256,
		___float512,
		___float1024,
	};

	template<uint32_t N>		//hopefully no one writes code that nests reference types billions of times to get an overflow here
	struct type_identifier {
		uint8_t data[N];
		constexpr type_identifier()
			:data() {}

		constexpr uint32_t length() const
		{
			return N;
		}

		static constexpr type_identifier create_for_value_type(type_identifier_enum tie)
		{
			type_identifier<1> ret;
			ret.data[0] = uint8_t(tie);
			return ret;
		}

		template<typename enum_base_type, enum_base_type numEntry>
		static constexpr type_identifier create_for_enum_type()
		{
			type_identifier<1 + uint32_t(sizeof(enum_base_type))> ret;
			ret.data[0] = uint8_t(type_identifier_enum::___enum);
			for (uint32_t i = 0; i < uint32_t(sizeof(enum_base_type)); i++)
				ret.data[i + 1] = uint8_t((numEntry >> (i * 8)) & 0xff);
			return ret;
		}

		template <typename element_type_identifier>
		static constexpr type_identifier create_for_array(element_type_identifier element_ti)
		{
			type_identifier<N> ret;
			ret.data[0] = uint8_t(type_identifier_enum::___array);
			for (uint32_t i = 0; i < N - 1; i++)
				ret.data[i + 1] = element_ti.data[i];
			return ret;
		}

		template <typename key_type_identifier, typename value_type_identifier>
		static constexpr type_identifier create_for_map(key_type_identifier key_ti, value_type_identifier value_ti)
		{
			type_identifier<N> ret;
			ret.data[0] = uint8_t(type_identifier_enum::___map);
			uint32_t writeIdx = 1;
			for (uint32_t i = 0; i < key_ti.length(); i++, writeIdx++)
				ret.data[writeIdx] = key_ti.data[i];
			for (uint32_t i = 0; i < value_ti.length(); i++, writeIdx++)
				ret.data[writeIdx] = value_ti.data[i];
			return ret;
		}

		template<typename ...Args>
		static constexpr type_identifier create_for_struct(uint8_t numMembers, Args ...args)
		{
			type_identifier<N> ret;
			ret.data[0] = uint8_t(type_identifier_enum::___struct);
			ret.data[1] = numMembers;
			fill_struct_member_ti<Args...>(ret.data + 2, args...);

			return ret;
		}

		template<uint32_t rhs_N>
		bool operator==(const type_identifier<rhs_N> &rhs) const
		{
			if (N != rhs_N)
				return false;
			for (uint32_t i = 0; i < N; i++)
				if (data[i] != rhs.data[i])
					return false;
			return true;
		}

		constexpr uint32_t get_serialize_size() const
		{
			return N + sizeof(uint32_t);
		}

		void serialize_out(uint8_t *buffer) const
		{
			*(uint32_t*)buffer = N;
			buffer += sizeof(uint32_t);
			for (uint32_t i = 0; i < N; i++)
				buffer[i] = data[i];
		}

	private:
		static constexpr void fill_struct_member_ti(uint8_t *p)
		{
		}

		template<typename member_type_identifier, typename ...Args>
		static constexpr void fill_struct_member_ti(uint8_t *p, member_type_identifier member_ti, Args ...args)
		{
			for (uint32_t i = 0; i < member_ti.length(); i++)
				p[i] = member_ti.data[i];
			fill_struct_member_ti(p + member_ti.length(), args...);
		}
	};

	template<type_identifier_enum _ti>
	struct simple_type_type_identifier {
		static constexpr auto value = type_identifier<1>::create_for_value_type(_ti);
	};

	template<typename element_type_identifier>
	struct ____array_type_identifier {
		static constexpr auto value = type_identifier<element_type_identifier::value.length() + 1>::create_for_array(element_type_identifier::value);
	};

	template<typename key_type_identifier, typename value_type_identifier>
	struct ____map_type_identifier {
		static constexpr auto value = type_identifier<key_type_identifier::value.length() + value_type_identifier::value.length() + 1>::create_for_map(key_type_identifier::value, value_type_identifier::value);
	};

	template<typename enum_base_type, enum_base_type numEntry>
	struct ____enum_type_type_identifier {
		static constexpr auto value = type_identifier<1 + uint32_t(sizeof(enum_base_type))>::template create_for_enum_type<enum_base_type, numEntry>();
	};
	// example for struct type identifier
	// For real structs, this code should be automatically generated by the transpiler
	//namespace {
	//	struct my_struct {
	//		___int32 i;
	//		___array<___int32> a;
	//	};
	//
	//	struct my_struct_type_identifier {
	//		static constexpr auto value
	//			= type_identifier<value_type_type_identifier<type_identifier_enum::___int32>::value.length() + array_type_identifier<value_type_type_identifier<type_identifier_enum::___int32>>::value.length() + 2>::create_for_struct
	//			(
	//				2,
	//				value_type_type_identifier<type_identifier_enum::___int32>::value,
	//				array_type_identifier<value_type_type_identifier<type_identifier_enum::___int32>>::value
	//			);
	//	};
	//}

}
